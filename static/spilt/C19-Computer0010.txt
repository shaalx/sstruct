计算机应用COMPUTER APPLICATIONS1999年 第19卷 第6期 Vol.19 No.6 1999Windows 95下串行通信编程技术及其实现郭峰林　朱才连　　摘　要　本文首先简单讨论MSDOS、16位Windows和Windows95下的通信编程差别，然后着重讲述32位Windows95 环境下的通信编程技术，最后给出利用该技术实现串行通信的实例。
0	 ATT	 1	 ﻿	 v
1	 FOB	 2	 计算机	 n
2	 ATT	 9	 应用	 v
3	 CMP	 2	 COMPUTER	 ws
4	 ATT	 5	 APPLICATIONS1999	 m
5	 ATT	 7	 年	 q
6	 ATT	 7	 第19	 m
7	 ATT	 9	 卷	 q
8	 ATT	 9	 第6	 m
9	 ATT	 13	 期	 q
10	 ATT	 11	 Vol.19	 m
11	 ATT	 12	 No.6	 m
12	 ATT	 13	 1999Windows	 m
13	 ATT	 14	 95	 m
14	 ADV	 15	 下	 nd
15	 HED	 -1	 串行	 v
16	 ATT	 18	 通信	 v
17	 COO	 16	 编程	 v
18	 VOB	 15	 技术	 n
19	 ADV	 20	 及其	 c
20	 COO	 15	 实现	 v
21	 ATT	 22	 郭峰林	 nh
22	 ATT	 23	 	 n
23	 SBV	 24	 朱才连	 nh
24	 VOB	 20	 	 v
25	 COO	 20	 摘	 v
26	 VOB	 25	 	 n
27	 ADV	 28	 要	 v
28	 COO	 25	 	 v
29	 SBV	 32	 本文	 r
30	 ADV	 32	 首先	 d
31	 ADV	 32	 简单	 a
32	 VOB	 28	 讨论	 v
33	 ATT	 44	 MSDOS	 ws
34	 WP	 44	 、	 wp
35	 ATT	 36	 16	 m
36	 ATT	 44	 位	 q
37	 ATT	 44	 Windows	 ws
38	 LAD	 42	 和	 c
39	 ATT	 40	 Windows95	 ws
40	 ATT	 42	 下	 nd
41	 RAD	 40	 的	 u
42	 ATT	 44	 通信	 v
43	 VOB	 42	 编程	 n
44	 VOB	 32	 差别	 n
45	 WP	 20	 ，	 wp
46	 ADV	 48	 然后	 c
47	 ADV	 48	 着重	 v
48	 ADV	 55	 讲述	 v
49	 ATT	 50	 32	 m
50	 ATT	 52	 位	 q
51	 ATT	 52	 Windows95	 ws
52	 ATT	 53	 环境	 n
53	 CMP	 48	 下	 nd
54	 RAD	 48	 的	 u
55	 COO	 20	 通信	 v
56	 ATT	 57	 编程	 n
57	 VOB	 55	 技术	 n
58	 WP	 20	 ，	 wp
59	 ADV	 60	 最后	 nd
60	 COO	 20	 给	 v
61	 CMP	 60	 出	 v
62	 ATT	 69	 利用	 v
63	 ATT	 64	 该	 r
64	 VOB	 62	 技术	 n
65	 COO	 62	 实现	 v
66	 ADV	 67	 串行	 v
67	 VOB	 65	 通信	 v
68	 RAD	 65	 的	 u
69	 VOB	 60	 实例	 n
70	 WP	 15	 。	 wp

在诸多的应用开发中，与外部硬件设备通信是常见的应用，而串行通信以其简单的硬件连接方式常常成为应用开发者的首选。
0	 ADV	 12	 在	 p
1	 ADV	 3	 诸多	 m
2	 RAD	 1	 的	 u
3	 ATT	 5	 应用	 v
4	 COO	 3	 开发	 v
5	 POB	 0	 中	 nd
6	 WP	 0	 ，	 wp
7	 ADV	 11	 与	 p
8	 ATT	 9	 外部	 nd
9	 ATT	 10	 硬件	 n
10	 POB	 7	 设备	 n
11	 SBV	 12	 通信	 v
12	 HED	 -1	 是	 v
13	 ADV	 15	 常见	 a
14	 RAD	 13	 的	 u
15	 VOB	 12	 应用	 v
16	 WP	 12	 ，	 wp
17	 ADV	 28	 而	 c
18	 ATT	 26	 串行	 v
19	 ADV	 25	 通信	 v
20	 ADV	 25	 以	 p
21	 ATT	 24	 其	 r
22	 ATT	 24	 简单	 a
23	 RAD	 22	 的	 u
24	 POB	 20	 硬件	 n
25	 ATT	 26	 连接	 v
26	 SBV	 28	 方式	 n
27	 ADV	 28	 常常	 d
28	 COO	 12	 成为	 v
29	 ATT	 32	 应用	 v
30	 VOB	 29	 开发者	 n
31	 RAD	 29	 的	 u
32	 VOB	 28	 首选	 v
33	 WP	 12	 。	 wp

然而串行通信编程从MSDOS、Windows3.1到Windows95各不相同，虽然在功能上越来越强，但是编程的复杂度也相应增大。
0	 ADV	 12	 然而	 c
1	 ATT	 3	 串行	 v
2	 COO	 1	 通信	 v
3	 SBV	 12	 编程	 n
4	 ADV	 8	 从	 p
5	 ATT	 7	 MSDOS	 ws
6	 WP	 7	 、	 wp
7	 POB	 4	 Windows3.1	 ws
8	 ADV	 12	 到	 v
9	 POB	 8	 Windows95	 ws
10	 ADV	 12	 各	 r
11	 ADV	 12	 不	 d
12	 HED	 -1	 相同	 a
13	 WP	 12	 ，	 wp
14	 ADV	 19	 虽然	 c
15	 ADV	 19	 在	 p
16	 ATT	 17	 功能	 n
17	 POB	 15	 上	 nd
18	 ADV	 19	 越来越	 d
19	 COO	 12	 强	 a
20	 WP	 12	 ，	 wp
21	 ADV	 26	 但是	 c
22	 ATT	 24	 编程	 v
23	 RAD	 22	 的	 u
24	 SBV	 26	 复杂度	 n
25	 ADV	 26	 也	 d
26	 COO	 12	 相应	 v
27	 VOB	 26	 增大	 v
28	 WP	 12	 。	 wp

　　笔者最近在Windows95环境下开发一套“公安110智能报警系统”，该系统需要对报警电话进行实时监控，以便能实时地进行接警和处警。
0	 ATT	 1	 	 v
1	 SBV	 7	 笔者	 n
2	 ADV	 7	 最近	 nt
3	 ADV	 7	 在	 p
4	 ATT	 5	 Windows95	 ws
5	 ATT	 6	 环境	 n
6	 POB	 3	 下	 nd
7	 HED	 -1	 开发	 v
8	 ATT	 9	 一	 m
9	 ATT	 15	 套	 q
10	 WP	 15	 “	 wp
11	 ATT	 13	 公安	 n
12	 ATT	 13	 110	 m
13	 SBV	 14	 智能	 n
14	 ATT	 15	 报警	 v
15	 VOB	 7	 系统	 n
16	 WP	 15	 ”	 wp
17	 WP	 7	 ，	 wp
18	 ATT	 19	 该	 r
19	 SBV	 20	 系统	 n
20	 COO	 7	 需要	 v
21	 ADV	 24	 对	 p
22	 POB	 21	 报警	 v
23	 VOB	 22	 电话	 n
24	 VOB	 20	 进行	 v
25	 SBV	 26	 实时	 n
26	 VOB	 24	 监控	 v
27	 WP	 20	 ，	 wp
28	 ADV	 32	 以便	 d
29	 ADV	 32	 能	 v
30	 ATT	 31	 实时	 n
31	 LAD	 29	 地	 u
32	 COO	 20	 进行	 v
33	 VOB	 32	 接警	 v
34	 LAD	 35	 和	 c
35	 COO	 33	 处警	 v
36	 WP	 7	 。	 wp

报警电话的监控是通过检测从电话交换机中馈送的RS232标准的串行通信信号，其中串行口通信采用3线方式。
0	 SBV	 4	 报警	 v
1	 VOB	 0	 电话	 n
2	 RAD	 0	 的	 u
3	 SBV	 4	 监控	 v
4	 HED	 -1	 是	 v
5	 ADV	 16	 通过	 p
6	 POB	 5	 检测	 v
7	 ADV	 11	 从	 p
8	 ATT	 9	 电话	 n
9	 ATT	 10	 交换机	 n
10	 POB	 7	 中	 nd
11	 ATT	 14	 馈送	 v
12	 RAD	 11	 的	 u
13	 ATT	 14	 RS232	 ws
14	 VOB	 6	 标准	 n
15	 RAD	 6	 的	 u
16	 VOB	 4	 串行	 v
17	 COO	 16	 通信	 v
18	 VOB	 17	 信号	 n
19	 WP	 16	 ，	 wp
20	 ATT	 21	 其中	 r
21	 COO	 16	 串	 v
22	 VOB	 21	 行口	 n
23	 COO	 21	 通信	 v
24	 VOB	 23	 采用	 v
25	 ATT	 26	 3	 m
26	 ATT	 27	 线	 q
27	 VOB	 24	 方式	 n
28	 WP	 4	 。	 wp

该系统采用Windows95下的Visual C++ 5.0编写，由于有关Windows95的串行口通信编程方面的资料少，串行通信编程的实例也不多见，笔者在成功开发“公安110智能报警系统”的基础上，取得了一些经验，现在将有关串行口通信方面的一些关键技术写出来，供广大的编程者借鉴、参考。
0	 ATT	 1	 该	 r
1	 SBV	 2	 系统	 n
2	 HED	 -1	 采用	 v
3	 ATT	 4	 Windows95	 ws
4	 ATT	 9	 下	 nd
5	 RAD	 4	 的	 u
6	 SBV	 9	 Visual	 ws
7	 SBV	 9	 C	 ws
8	 ADV	 9	 5.0	 m
9	 VOB	 2	 编写	 v
10	 WP	 2	 ，	 wp
11	 ADV	 31	 由于	 c
12	 ATT	 18	 有关	 v
13	 POB	 12	 Windows95	 ws
14	 RAD	 12	 的	 u
15	 ATT	 18	 串行口	 ns
16	 ATT	 18	 通信	 v
17	 VOB	 16	 编程	 n
18	 ATT	 20	 方面	 n
19	 RAD	 18	 的	 u
20	 SBV	 21	 资料	 n
21	 POB	 11	 少	 a
22	 WP	 11	 ，	 wp
23	 ATT	 27	 串行	 v
24	 COO	 23	 通信	 v
25	 VOB	 24	 编程	 n
26	 RAD	 23	 的	 u
27	 FOB	 31	 实例	 n
28	 ADV	 31	 也	 d
29	 ADV	 31	 不	 d
30	 ADV	 31	 多	 a
31	 COO	 2	 见	 v
32	 WP	 2	 ，	 wp
33	 SBV	 48	 笔者	 n
34	 ADV	 48	 在	 p
35	 ADV	 36	 成功	 a
36	 ATT	 45	 开发	 v
37	 WP	 41	 “	 wp
38	 ATT	 40	 公安	 n
39	 ATT	 40	 110	 m
40	 SBV	 41	 智能	 n
41	 COO	 36	 报警	 v
42	 VOB	 41	 系统	 n
43	 WP	 41	 ”	 wp
44	 RAD	 36	 的	 u
45	 ATT	 46	 基础	 n
46	 POB	 34	 上	 nd
47	 WP	 34	 ，	 wp
48	 COO	 2	 取得	 v
49	 RAD	 48	 了	 u
50	 ATT	 51	 一些	 m
51	 VOB	 48	 经验	 n
52	 WP	 2	 ，	 wp
53	 ADV	 64	 现在	 nt
54	 ADV	 64	 将	 p
55	 ATT	 63	 有关	 v
56	 ATT	 59	 串	 v
57	 VOB	 56	 行口	 n
58	 COO	 56	 通信	 v
59	 POB	 55	 方面	 n
60	 RAD	 55	 的	 u
61	 ATT	 63	 一些	 m
62	 ATT	 63	 关键	 a
63	 POB	 54	 技术	 n
64	 COO	 2	 写	 v
65	 CMP	 64	 出来	 v
66	 WP	 64	 ，	 wp
67	 COO	 64	 供	 v
68	 ATT	 70	 广大	 b
69	 RAD	 68	 的	 u
70	 VOB	 67	 编程者	 n
71	 VOB	 67	 借鉴	 v
72	 WP	 73	 、	 wp
73	 COO	 71	 参考	 v
74	 WP	 2	 。	 wp

2　下串行通信编程特征　　MSDOS下的串行通信编程较简单，通信编程可以直接对串口的物理地址进行编程操作同时配合BIOS调用，即可实现串行口数据读写。
0	 ATT	 1	 2	 m
1	 ATT	 2	 	 q
2	 ADV	 3	 下	 nd
3	 ATT	 13	 串行	 v
4	 COO	 3	 通信	 v
5	 COO	 3	 编程	 v
6	 VOB	 5	 特征	 n
7	 COO	 3	 	 v
8	 ATT	 9	 MSDOS	 ws
9	 CMP	 7	 下	 nd
10	 RAD	 3	 的	 u
11	 ATT	 13	 串行	 v
12	 COO	 11	 通信	 v
13	 SBV	 15	 编程	 n
14	 ADV	 15	 较	 d
15	 HED	 -1	 简单	 a
16	 WP	 15	 ，	 wp
17	 SBV	 28	 通信	 v
18	 VOB	 17	 编程	 n
19	 ADV	 28	 可以	 v
20	 ADV	 26	 直接	 a
21	 ADV	 26	 对	 p
22	 ATT	 25	 串口	 ns
23	 RAD	 22	 的	 u
24	 ATT	 25	 物理	 n
25	 POB	 21	 地址	 n
26	 ATT	 28	 进行	 v
27	 VOB	 26	 编程	 n
28	 COO	 15	 操作	 v
29	 ADV	 30	 同时	 d
30	 COO	 28	 配合	 v
31	 SBV	 32	 BIOS	 ws
32	 COO	 30	 调用	 v
33	 WP	 28	 ，	 wp
34	 COO	 28	 即可	 v
35	 VOB	 34	 实现	 v
36	 ATT	 38	 串	 v
37	 VOB	 36	 行口	 n
38	 VOB	 35	 数据	 n
39	 COO	 35	 读	 v
40	 COO	 39	 写	 v
41	 WP	 15	 。	 wp

　　在Windows下，串行口作为系统资源，由设备驱动程序统一管理，用户不能象在MSDOS下一样直接对串行口硬件端口进行编程。
0	 ADV	 6	 	 v
1	 CMP	 0	 在	 p
2	 ATT	 3	 Windows	 ws
3	 POB	 1	 下	 nd
4	 WP	 1	 ，	 wp
5	 COO	 0	 串行口	 v
6	 HED	 -1	 作为	 v
7	 ATT	 8	 系统	 n
8	 VOB	 6	 资源	 n
9	 WP	 6	 ，	 wp
10	 ADV	 12	 由	 p
11	 POB	 10	 设备	 n
12	 COO	 6	 驱动	 v
13	 SBV	 14	 程序	 n
14	 ADV	 15	 统一	 a
15	 VOB	 12	 管理	 v
16	 WP	 12	 ，	 wp
17	 SBV	 20	 用户	 n
18	 ADV	 19	 不	 d
19	 ADV	 20	 能	 v
20	 SBV	 31	 象	 n
21	 ADV	 31	 在	 p
22	 ATT	 23	 MSDOS	 ws
23	 POB	 21	 下	 nd
24	 RAD	 21	 一样	 u
25	 ADV	 31	 直接	 a
26	 ADV	 31	 对	 p
27	 POB	 26	 串	 v
28	 ATT	 29	 行口	 n
29	 ATT	 30	 硬件	 n
30	 VOB	 27	 端口	 n
31	 COO	 12	 进行	 v
32	 VOB	 31	 编程	 v
33	 WP	 12	 。	 wp

16位的Windows3.1操作系统提供了专门的串行通信的API函数：OpenComm()、CloseComm()、ReadComm()、 WriteComm()等，通过这些专用API（Application Programming Interfaces）函数来设置和读、写串行口。
0	 ATT	 1	 16	 m
1	 ATT	 4	 位	 q
2	 RAD	 1	 的	 u
3	 ATT	 4	 Windows3.1	 ws
4	 ADV	 5	 操作系统	 i
5	 HED	 -1	 提供	 v
6	 RAD	 5	 了	 u
7	 ATT	 13	 专门	 b
8	 RAD	 7	 的	 u
9	 ATT	 13	 串行	 v
10	 COO	 9	 通信	 v
11	 RAD	 9	 的	 u
12	 ATT	 13	 API	 ws
13	 VOB	 5	 函数	 n
14	 WP	 13	 ：	 wp
15	 CMP	 13	 OpenComm	 nh
16	 WP	 23	 (	 wp
17	 WP	 23	 )	 wp
18	 WP	 23	 、	 wp
19	 ATT	 23	 CloseComm	 ws
20	 WP	 23	 (	 wp
21	 WP	 23	 )	 wp
22	 WP	 23	 、	 wp
23	 COO	 13	 ReadComm	 nh
24	 WP	 27	 (	 wp
25	 WP	 27	 )	 wp
26	 WP	 27	 、	 wp
27	 COO	 23	 WriteComm	 nh
28	 WP	 23	 (	 wp
29	 WP	 23	 )	 wp
30	 RAD	 13	 等	 u
31	 WP	 5	 ，	 wp
32	 ADV	 43	 通过	 p
33	 ATT	 41	 这些	 r
34	 ATT	 41	 专用	 v
35	 VOB	 34	 API	 ws
36	 WP	 37	 （	 wp
37	 ATT	 41	 Application	 ws
38	 ATT	 41	 Programming	 ws
39	 ATT	 41	 Interfaces	 ws
40	 WP	 39	 ）	 wp
41	 POB	 32	 函数	 n
42	 ADV	 43	 来	 v
43	 COO	 5	 设置	 v
44	 LAD	 45	 和	 c
45	 COO	 43	 读	 v
46	 WP	 47	 、	 wp
47	 COO	 43	 写	 v
48	 ATT	 49	 串	 q
49	 VOB	 47	 行口	 n
50	 WP	 5	 。	 wp

而Windows95将串行口和其它通信设备如Modern、传真机等统一视作文件，对串行口的打开、关闭、读写等操作与操作普通文件的API函数相同，如CreateFile()、CloseHandel()、ReadFile()、WriteFile()，正是由于这些函数的“多态性”， 同时还由于需要结合Windows95的线程编程、事件驱动等新技术，因而使得Windows95下的串行口通信编程比较复杂。
0	 ADV	 3	 而	 c
1	 SBV	 3	 Windows95	 ws
2	 ADV	 3	 将	 d
3	 HED	 -1	 串	 v
4	 VOB	 3	 行口	 n
5	 LAD	 8	 和	 c
6	 ATT	 8	 其它	 r
7	 ATT	 8	 通信	 v
8	 COO	 4	 设备	 n
9	 CMP	 8	 如	 v
10	 POB	 9	 Modern	 ws
11	 WP	 12	 、	 wp
12	 VOB	 8	 传真机	 n
13	 RAD	 8	 等	 u
14	 ADV	 15	 统一	 a
15	 ATT	 36	 视	 v
16	 COO	 15	 作	 v
17	 VOB	 16	 文件	 n
18	 WP	 15	 ，	 wp
19	 ADV	 22	 对	 p
20	 POB	 19	 串行口	 n
21	 RAD	 19	 的	 u
22	 COO	 15	 打开	 v
23	 WP	 24	 、	 wp
24	 COO	 22	 关闭	 v
25	 WP	 26	 、	 wp
26	 COO	 22	 读	 v
27	 COO	 26	 写	 v
28	 RAD	 22	 等	 u
29	 ATT	 36	 操作	 v
30	 LAD	 31	 与	 c
31	 COO	 29	 操作	 v
32	 ATT	 33	 普通	 a
33	 VOB	 29	 文件	 n
34	 RAD	 29	 的	 u
35	 ATT	 36	 API	 ws
36	 SBV	 37	 函数	 n
37	 HED	 3	 相同	 a
38	 WP	 37	 ，	 wp
39	 COO	 37	 如	 v
40	 POB	 39	 CreateFile	 ws
41	 WP	 3	 (	 wp
42	 WP	 3	 )	 wp
43	 WP	 44	 、	 wp
44	 COO	 3	 CloseHandel	 ws
45	 WP	 3	 (	 wp
46	 WP	 3	 )	 wp
47	 WP	 48	 、	 wp
48	 COO	 3	 ReadFile	 nh
49	 WP	 52	 (	 wp
50	 WP	 52	 )	 wp
51	 WP	 52	 、	 wp
52	 COO	 48	 WriteFile	 nh
53	 WP	 3	 (	 wp
54	 WP	 3	 )	 wp
55	 WP	 3	 ，	 wp
56	 ADV	 57	 正是	 v
57	 COO	 3	 由于	 c
58	 ATT	 59	 这些	 r
59	 ATT	 62	 函数	 n
60	 RAD	 59	 的	 u
61	 WP	 62	 “	 wp
62	 POB	 57	 多态性	 n
63	 WP	 62	 ”	 wp
64	 WP	 3	 ，	 wp
65	 ADV	 68	 同时	 c
66	 ADV	 67	 还	 d
67	 ADV	 68	 由于	 p
68	 COO	 3	 需要	 v
69	 ATT	 73	 结合	 v
70	 VOB	 69	 Windows95	 ws
71	 RAD	 69	 的	 u
72	 ATT	 73	 线程	 n
73	 ATT	 79	 编程	 n
74	 WP	 76	 、	 wp
75	 SBV	 76	 事件	 n
76	 COO	 73	 驱动	 v
77	 RAD	 73	 等	 u
78	 ATT	 79	 新	 a
79	 VOB	 68	 技术	 n
80	 WP	 3	 ，	 wp
81	 ADV	 82	 因而	 c
82	 COO	 3	 使得	 v
83	 ATT	 84	 Windows95	 ws
84	 ATT	 86	 下	 nd
85	 RAD	 84	 的	 u
86	 ATT	 88	 串行口	 ns
87	 ATT	 88	 通信	 v
88	 DBL	 82	 编程	 n
89	 ADV	 90	 比较	 d
90	 VOB	 82	 复杂	 a
91	 WP	 3	 。	 wp

3　Windows95下串行通信API函数　　在Windows95中将串行口与文件的统一了起来，对它们的打开、读、写、关闭等操作都使用相同的API函数，但是它们之间又有差别，譬如串行口不能象文件一样可以被删除，这些差别体现在API函数中部分参数的设置上。
0	 ATT	 1	 3	 m
1	 ATT	 7	 	 q
2	 ATT	 3	 Windows95	 ws
3	 ADV	 4	 下	 nd
4	 ATT	 7	 串行	 v
5	 COO	 4	 通信	 v
6	 ATT	 7	 API	 ws
7	 SBV	 17	 函数	 n
8	 SBV	 17	 	 v
9	 ADV	 12	 在	 p
10	 ATT	 11	 Windows95	 ws
11	 POB	 9	 中将	 n
12	 VOB	 8	 串	 v
13	 VOB	 12	 行口	 n
14	 ADV	 17	 与	 p
15	 POB	 14	 文件	 n
16	 RAD	 14	 的	 u
17	 HED	 -1	 统一	 v
18	 RAD	 17	 了	 u
19	 CMP	 17	 起来	 v
20	 WP	 17	 ，	 wp
21	 ADV	 32	 对	 p
22	 ATT	 24	 它们	 r
23	 RAD	 22	 的	 u
24	 POB	 21	 打开	 v
25	 WP	 26	 、	 wp
26	 COO	 24	 读	 v
27	 WP	 28	 、	 wp
28	 COO	 24	 写	 v
29	 WP	 30	 、	 wp
30	 COO	 24	 关闭	 v
31	 RAD	 24	 等	 u
32	 COO	 17	 操作	 v
33	 ADV	 34	 都	 d
34	 COO	 32	 使用	 v
35	 ATT	 38	 相同	 a
36	 RAD	 35	 的	 u
37	 ATT	 38	 API	 ws
38	 VOB	 34	 函数	 n
39	 WP	 17	 ，	 wp
40	 ADV	 44	 但是	 c
41	 ATT	 42	 它们	 r
42	 SBV	 44	 之间	 nd
43	 ADV	 44	 又	 d
44	 COO	 17	 有	 v
45	 VOB	 44	 差别	 n
46	 WP	 44	 ，	 wp
47	 FOB	 56	 譬如	 v
48	 VOB	 47	 串行口	 n
49	 ADV	 50	 不	 d
50	 ADV	 51	 能	 v
51	 COO	 47	 象	 v
52	 VOB	 51	 文件	 n
53	 RAD	 47	 一样	 u
54	 ADV	 56	 可以	 v
55	 ADV	 56	 被	 p
56	 COO	 44	 删除	 v
57	 WP	 17	 ，	 wp
58	 ATT	 59	 这些	 r
59	 SBV	 60	 差别	 n
60	 COO	 17	 体现	 v
61	 CMP	 60	 在	 p
62	 ATT	 63	 API	 ws
63	 ATT	 64	 函数	 n
64	 ATT	 66	 中	 nd
65	 ATT	 66	 部分	 m
66	 ATT	 68	 参数	 n
67	 RAD	 66	 的	 u
68	 ATT	 69	 设置	 v
69	 POB	 61	 上	 nd
70	 WP	 17	 。	 wp

　　弄清串行通信API函数的用法是掌握串行通信编程技术的关键。
0	 SBV	 1	 	 n
1	 ATT	 7	 弄清	 v
2	 COO	 1	 串行	 v
3	 COO	 1	 通信	 v
4	 ATT	 5	 API	 ws
5	 VOB	 3	 函数	 n
6	 RAD	 1	 的	 u
7	 SBV	 8	 用法	 n
8	 HED	 -1	 是	 v
9	 ATT	 15	 掌握	 v
10	 COO	 9	 串行	 v
11	 COO	 9	 通信	 v
12	 VOB	 9	 编程	 v
13	 VOB	 9	 技术	 n
14	 RAD	 9	 的	 u
15	 VOB	 8	 关键	 n
16	 WP	 8	 。	 wp

下面介绍几个与串行通信编程密切相关的API函数，着重说明这些API函数在进行串行通信时参数设置需要注意的地方。
0	 ADV	 1	 下面	 nd
1	 SBV	 15	 介绍	 v
2	 ATT	 3	 几	 m
3	 ATT	 12	 个	 q
4	 ADV	 9	 与	 c
5	 SBV	 8	 串行	 v
6	 SBV	 8	 通信	 v
7	 SBV	 8	 编程	 v
8	 POB	 4	 密切	 a
9	 ATT	 12	 相关	 v
10	 RAD	 9	 的	 u
11	 ATT	 12	 API	 ws
12	 VOB	 1	 函数	 n
13	 WP	 1	 ，	 wp
14	 ADV	 15	 着重	 v
15	 HED	 -1	 说明	 v
16	 ATT	 18	 这些	 r
17	 ATT	 18	 API	 ws
18	 SBV	 25	 函数	 n
19	 ADV	 25	 在	 p
20	 ATT	 23	 进行	 v
21	 SBV	 22	 串行	 v
22	 VOB	 20	 通信	 v
23	 POB	 19	 时	 n
24	 DBL	 23	 参数	 n
25	 VOB	 15	 设置	 v
26	 ATT	 29	 需要	 v
27	 VOB	 26	 注意	 v
28	 RAD	 26	 的	 u
29	 VOB	 25	 地方	 n
30	 WP	 15	 。	 wp

其它没有提及的函数及参数可以参考Windows95 API函数手册。
0	 SBV	 2	 其它	 r
1	 ADV	 2	 没有	 d
2	 ATT	 4	 提及	 v
3	 RAD	 2	 的	 u
4	 SBV	 8	 函数	 n
5	 LAD	 6	 及	 c
6	 COO	 4	 参数	 n
7	 ADV	 8	 可以	 v
8	 HED	 -1	 参考	 v
9	 ATT	 12	 Windows95	 ws
10	 ATT	 11	 API	 ws
11	 ATT	 12	 函数	 n
12	 VOB	 8	 手册	 n
13	 WP	 8	 。	 wp

3.1　打开串行口API函数　　Windows95通信会话以调用CreateFile()函数打开串行口开始。
0	 ATT	 1	 3.1	 m
1	 SBV	 2	 	 n
2	 HED	 -1	 打开	 v
3	 COO	 2	 串	 v
4	 VOB	 3	 行口	 n
5	 ATT	 6	 API	 ws
6	 SBV	 7	 函数	 n
7	 COO	 2	 	 v
8	 SBV	 9	 Windows95	 ws
9	 COO	 2	 通信	 v
10	 ATT	 11	 会	 v
11	 VOB	 9	 话	 n
12	 ADV	 13	 以	 p
13	 COO	 2	 调用	 v
14	 VOB	 13	 CreateFile	 ws
15	 WP	 13	 (	 wp
16	 WP	 2	 )	 wp
17	 SBV	 18	 函数	 n
18	 COO	 2	 打开	 v
19	 COO	 18	 串	 v
20	 VOB	 19	 行口	 n
21	 COO	 18	 开始	 v
22	 WP	 2	 。	 wp

调用CreateFile()打开串口成功，返回一个操作句柄。
0	 SBV	 4	 调用	 v
1	 VOB	 0	 CreateFile	 ws
2	 WP	 1	 (	 wp
3	 WP	 1	 )	 wp
4	 HED	 -1	 打开	 v
5	 SBV	 6	 串口	 n
6	 VOB	 4	 成功	 a
7	 WP	 4	 ，	 wp
8	 COO	 4	 返回	 v
9	 ATT	 11	 一个	 m
10	 ATT	 11	 操作	 v
11	 VOB	 8	 句柄	 n
12	 WP	 4	 。	 wp

该句柄供随后对串行口的设置、读写等操作用。
0	 ATT	 1	 该	 r
1	 ATT	 2	 句	 q
2	 SBV	 3	 柄	 n
3	 HED	 -1	 供	 v
4	 ADV	 9	 随后	 d
5	 ADV	 9	 对	 p
6	 POB	 5	 串	 v
7	 VOB	 6	 行口	 n
8	 RAD	 5	 的	 u
9	 VOB	 3	 设置	 v
10	 WP	 11	 、	 wp
11	 COO	 9	 读	 v
12	 ATT	 14	 写	 v
13	 RAD	 12	 等	 u
14	 VOB	 11	 操作用	 n
15	 WP	 3	 。	 wp

　　CreateFile()函数原型:　HANDLE CreateFile(LPCTSTR szDevice, DWORD dwAccess,DWORD dwShareMode, LPSECURITY—ATTRIBUTES lpSA,DWORD dwCreate, DWORD dwFlagsAndAttributes,HANDLE hTemplateFile );　　调用此函数要注意这几个参数的设置：dwShareMode指定该端口的共享属性。
0	 SBV	 15	 	 v
1	 ATT	 5	 CreateFile	 ws
2	 WP	 1	 (	 wp
3	 WP	 1	 )	 wp
4	 ATT	 5	 函数	 n
5	 VOB	 0	 原型	 n
6	 WP	 0	 :	 wp
7	 SBV	 15	 	 v
8	 VOB	 7	 HANDLE	 ws
9	 SBV	 15	 CreateFile	 ws
10	 WP	 9	 (	 wp
11	 SBV	 15	 LPCTSTR	 ws
12	 ATT	 15	 szDevice	 ws
13	 WP	 15	 ,	 wp
14	 SBV	 15	 DWORD	 ws
15	 HED	 -1	 dwAccess	 v
16	 WP	 18	 ,	 wp
17	 SBV	 18	 DWORD	 ws
18	 COO	 15	 dwShareMode	 v
19	 WP	 21	 ,	 wp
20	 ATT	 21	 LPSECURITY—ATTRIBUTES	 ws
21	 VOB	 18	 lpSA	 ws
22	 WP	 21	 ,	 wp
23	 SBV	 27	 DWORD	 ws
24	 ATT	 27	 dwCreate	 ws
25	 WP	 27	 ,	 wp
26	 SBV	 27	 DWORD	 ws
27	 COO	 15	 dwFlagsAndAttributes	 v
28	 WP	 30	 ,	 wp
29	 ATT	 30	 HANDLE	 ws
30	 VOB	 27	 hTemplateFile	 nh
31	 WP	 15	 )	 wp

该参数是为文件共享提供的，串行口不能作为共享设备。
0	 ATT	 1	 该	 r
1	 SBV	 2	 参数	 n
2	 HED	 -1	 是	 v
3	 ADV	 6	 为	 p
4	 FOB	 5	 文件	 n
5	 POB	 3	 共享	 v
6	 VOB	 2	 提供	 v
7	 RAD	 6	 的	 u
8	 WP	 2	 ，	 wp
9	 SBV	 13	 串	 v
10	 VOB	 9	 行口	 n
11	 ADV	 12	 不	 d
12	 ADV	 13	 能	 v
13	 COO	 2	 作为	 p
14	 VOB	 13	 共享	 v
15	 VOB	 14	 设备	 n
16	 WP	 2	 。	 wp

故参数值必须为0，这是文件与通信设备之间的主要差异之一；dwCreate必须为OPEN—EXISTING。
0	 ATT	 1	 故参	 n
1	 SBV	 3	 数值	 n
2	 ADV	 3	 必须	 d
3	 HED	 -1	 为	 v
4	 VOB	 3	 0	 m
5	 WP	 3	 ，	 wp
6	 SBV	 7	 这	 r
7	 COO	 3	 是	 v
8	 ATT	 12	 文件	 n
9	 LAD	 10	 与	 c
10	 COO	 8	 通信	 v
11	 VOB	 10	 设备	 n
12	 ATT	 15	 之间	 nd
13	 RAD	 12	 的	 u
14	 ATT	 15	 主要	 b
15	 ATT	 16	 差异	 n
16	 VOB	 7	 之一	 r
17	 WP	 7	 ；	 wp

故参数值必须为0，这是文件与通信设备之间的主要差异之一；dwCreate必须为OPEN—EXISTING。
0	 SBV	 2	 dwCreate	 ws
1	 ADV	 2	 必须	 d
2	 HED	 -1	 为	 v
3	 VOB	 2	 OPEN—EXISTING	 ws
4	 WP	 2	 。	 wp

因为CreateFile()只能打开存在的端口，而不能象创建新文件一样创建物理上不存在的新串口；dwFlagsAndAttributes描述了该端口的各种属性。
0	 ADV	 5	 因为	 c
1	 WP	 0	 CreateFile	 ws
2	 WP	 0	 (	 wp
3	 WP	 0	 )	 wp
4	 ADV	 5	 只能	 v
5	 HED	 -1	 打开	 v
6	 ATT	 8	 存在	 v
7	 RAD	 6	 的	 u
8	 VOB	 5	 端口	 n
9	 WP	 5	 ，	 wp
10	 ADV	 17	 而	 c
11	 ADV	 12	 不	 d
12	 ADV	 17	 能	 v
13	 DBL	 12	 象	 n
14	 COO	 12	 创建	 v
15	 VOB	 14	 新文件	 n
16	 RAD	 12	 一样	 u
17	 COO	 5	 创建	 v
18	 ATT	 19	 物理	 n
19	 ADV	 21	 上	 nd
20	 ADV	 21	 不	 d
21	 ATT	 24	 存在	 v
22	 RAD	 21	 的	 u
23	 ATT	 24	 新	 a
24	 VOB	 17	 串口	 n
25	 WP	 5	 ；	 wp

因为CreateFile()只能打开存在的端口，而不能象创建新文件一样创建物理上不存在的新串口；dwFlagsAndAttributes描述了该端口的各种属性。
0	 ADV	 1	 dwFlagsAndAttributes	 v
1	 HED	 -1	 描述	 v
2	 RAD	 1	 了	 u
3	 ATT	 4	 该	 r
4	 ATT	 7	 端口	 n
5	 RAD	 4	 的	 u
6	 ATT	 7	 各种	 r
7	 VOB	 1	 属性	 n
8	 WP	 1	 。	 wp

对于文件来说，具有多种属性（只读、隐藏、系统）是可能的，但是对于串行口，唯一有意义的设置是FILE—FLAG—OVERLAPPED；参数hTemplateFile必须为NULL。
0	 ADV	 15	 对于	 p
1	 POB	 0	 文件	 n
2	 RAD	 0	 来说	 u
3	 WP	 0	 ，	 wp
4	 SBV	 15	 具有	 v
5	 ATT	 6	 多种	 m
6	 VOB	 4	 属性	 n
7	 WP	 9	 （	 wp
8	 ADV	 9	 只	 d
9	 SBV	 15	 读	 v
10	 WP	 11	 、	 wp
11	 COO	 9	 隐藏	 v
12	 WP	 13	 、	 wp
13	 VOB	 9	 系统	 n
14	 WP	 9	 ）	 wp
15	 HED	 -1	 是	 v
16	 VOB	 15	 可能	 v
17	 RAD	 16	 的	 u
18	 WP	 15	 ，	 wp
19	 ADV	 27	 但是	 c
20	 ADV	 27	 对于	 p
21	 POB	 20	 串行口	 n
22	 WP	 20	 ，	 wp
23	 ATT	 27	 唯一	 b
24	 ADV	 27	 有	 v
25	 VOB	 24	 意义	 n
26	 RAD	 24	 的	 u
27	 COO	 15	 设置	 v
28	 COO	 27	 是	 v
29	 VOB	 28	 FILE—FLAG—OVERLAPPED	 ws
30	 WP	 15	 ；	 wp

对于文件来说，具有多种属性（只读、隐藏、系统）是可能的，但是对于串行口，唯一有意义的设置是FILE—FLAG—OVERLAPPED；参数hTemplateFile必须为NULL。
0	 SBV	 3	 参数	 n
1	 VOB	 0	 hTemplateFile	 ws
2	 ADV	 3	 必须	 d
3	 HED	 -1	 为	 v
4	 VOB	 3	 NULL	 ws
5	 WP	 3	 。	 wp

　　返回值：若成功，返回创建的句柄；否则返回，INVALID—HANDLE—VALUE.　　举例：打开串行口1　HANDLE hComm;　　　　　　　　　　　　　　　　　　　　　　　　　　　//定义句柄变量　hComm = CreateFile( "COM1", 　GENERIC—READ|GENERIC—WRITE,NULL,NULL,　OPEN—EXISTING,FILE—FLAG—OVERLAPPED,NULL);　if (hComm == INVALID—HANDLE—VALUE) {……. 　// 打开串口错误的处理}3.2　配置串行口API函数　　串行口打开成功，接下来可以配置串行口通信参数如波特率、数据位数、停止位、校验位等。
0	 SBV	 1	 	 n
1	 HED	 -1	 返回值	 v
2	 WP	 1	 ：	 wp
3	 ADV	 4	 若	 c
4	 VOB	 1	 成功	 a
5	 WP	 1	 ，	 wp
6	 COO	 1	 返回	 v
7	 ATT	 9	 创建	 v
8	 RAD	 7	 的	 u
9	 VOB	 6	 句柄	 n
10	 WP	 1	 ；	 wp

　　返回值：若成功，返回创建的句柄；否则返回，INVALID—HANDLE—VALUE.　　举例：打开串行口1　HANDLE hComm;　　　　　　　　　　　　　　　　　　　　　　　　　　　//定义句柄变量　hComm = CreateFile( "COM1", 　GENERIC—READ|GENERIC—WRITE,NULL,NULL,　OPEN—EXISTING,FILE—FLAG—OVERLAPPED,NULL);　if (hComm == INVALID—HANDLE—VALUE) {……. 　// 打开串口错误的处理}3.2　配置串行口API函数　　串行口打开成功，接下来可以配置串行口通信参数如波特率、数据位数、停止位、校验位等。
0	 ADV	 1	 否则	 c
1	 HED	 -1	 返回	 v
2	 WP	 1	 ，	 wp
3	 ATT	 6	 INVALID—HANDLE—VALUE	 ws
4	 WP	 6	 .	 wp
5	 SBV	 6	 	 n
6	 COO	 1	 举例	 v
7	 WP	 1	 ：	 wp
8	 VOB	 1	 打开	 v
9	 COO	 8	 串	 v
10	 VOB	 9	 行口1	 n
11	 COO	 8	 	 v
12	 ATT	 13	 HANDLE	 ws
13	 VOB	 11	 hComm	 n

修改这些参数时要和设备控制块DCB(Device Control Block)打交道，DCB有近30个数据成员，是一个很复杂的数据结构，全部弄清楚它们的含义相当费时。
0	 ATT	 3	 修改	 v
1	 ATT	 2	 这些	 r
2	 VOB	 0	 参数	 n
3	 ADV	 7	 时	 n
4	 ADV	 7	 要	 v
5	 ADV	 7	 和	 p
6	 POB	 5	 设备	 n
7	 HED	 -1	 控制	 v
8	 ATT	 15	 块	 q
9	 RAD	 8	 DCB	 ws
10	 WP	 8	 (	 wp
11	 SBV	 15	 Device	 ws
12	 ADV	 15	 Control	 ws
13	 SBV	 15	 Block	 ws
14	 WP	 15	 )	 wp
15	 VOB	 7	 打交道	 v
16	 WP	 7	 ，	 wp
17	 SBV	 18	 DCB	 ws
18	 COO	 7	 有	 v
19	 ATT	 20	 近	 v
20	 ATT	 21	 30	 m
21	 ATT	 23	 个	 q
22	 ATT	 23	 数据	 n
23	 VOB	 18	 成员	 n
24	 WP	 18	 ，	 wp
25	 COO	 18	 是	 v
26	 ATT	 31	 一个	 m
27	 ADV	 28	 很	 d
28	 ATT	 31	 复杂	 a
29	 RAD	 28	 的	 u
30	 ATT	 31	 数据	 n
31	 VOB	 25	 结构	 n
32	 WP	 7	 ，	 wp
33	 ADV	 34	 全部	 m
34	 COO	 7	 弄	 v
35	 CMP	 34	 清楚	 a
36	 ATT	 38	 它们	 r
37	 RAD	 36	 的	 u
38	 SBV	 40	 含义	 n
39	 ADV	 40	 相当	 d
40	 COO	 34	 费时	 a
41	 WP	 7	 。	 wp

而对于采用3线方式的串行通信来说，DCB结构中绝大多数参数可以不予考虑，因为只要设置好波特率、数据位、停止位、校验位等几个关键参数就行。
0	 ADV	 17	 而	 c
1	 ADV	 17	 对于	 p
2	 ADV	 7	 采用	 v
3	 ATT	 4	 3	 m
4	 ATT	 5	 线	 q
5	 VOB	 2	 方式	 n
6	 RAD	 2	 的	 u
7	 POB	 1	 串行	 v
8	 COO	 7	 通信	 v
9	 RAD	 1	 来说	 u
10	 WP	 1	 ，	 wp
11	 ATT	 12	 DCB	 ws
12	 ATT	 13	 结构	 n
13	 ATT	 15	 中	 nd
14	 ATT	 15	 绝大多数	 i
15	 SBV	 17	 参数	 n
16	 ADV	 17	 可以	 v
17	 HED	 -1	 不予	 v
18	 VOB	 17	 考虑	 v
19	 WP	 17	 ，	 wp
20	 ADV	 22	 因为	 c
21	 ADV	 22	 只要	 c
22	 COO	 17	 设置	 v
23	 CMP	 22	 好	 a
24	 VOB	 22	 波特率	 n
25	 WP	 27	 、	 wp
26	 ATT	 27	 数据	 n
27	 COO	 24	 位	 n
28	 WP	 29	 、	 wp
29	 COO	 24	 停止	 v
30	 VOB	 29	 位	 q
31	 WP	 32	 、	 wp
32	 COO	 24	 校验位	 n
33	 RAD	 24	 等	 u
34	 ATT	 35	 几	 m
35	 ATT	 37	 个	 q
36	 ATT	 37	 关键	 n
37	 SBV	 39	 参数	 n
38	 ADV	 39	 就	 d
39	 COO	 22	 行	 a
40	 WP	 17	 。	 wp

这里介绍一种简捷的方法可以做到不了解DCB的详细内容也可以设置好串行通信参数。
0	 SBV	 1	 这里	 r
1	 HED	 -1	 介绍	 v
2	 ATT	 3	 一	 m
3	 ATT	 6	 种	 q
4	 ATT	 6	 简捷	 a
5	 RAD	 4	 的	 u
6	 VOB	 1	 方法	 n
7	 ADV	 8	 可以	 v
8	 ATT	 14	 做到	 v
9	 ADV	 10	 不	 d
10	 VOB	 8	 了解	 v
11	 VOB	 10	 DCB	 ws
12	 RAD	 8	 的	 u
13	 ATT	 14	 详细	 a
14	 SBV	 17	 内容	 n
15	 ADV	 17	 也	 d
16	 ADV	 17	 可以	 v
17	 COO	 1	 设置	 v
18	 CMP	 17	 好	 a
19	 ATT	 21	 串行	 v
20	 COO	 19	 通信	 v
21	 VOB	 17	 参数	 n
22	 WP	 1	 。	 wp

　　通过下面的程序来说明串行通信参数的设置方法。
0	 SBV	 5	 	 n
1	 ADV	 5	 通过	 p
2	 ATT	 4	 下面	 nd
3	 RAD	 2	 的	 u
4	 POB	 1	 程序来	 nh
5	 HED	 -1	 说明	 v
6	 ADV	 10	 串行	 v
7	 COO	 6	 通信	 v
8	 VOB	 7	 参数	 n
9	 RAD	 6	 的	 u
10	 VOB	 5	 设置	 v
11	 VOB	 10	 方法	 n
12	 WP	 5	 。	 wp

例程中利用BuildCommDCB函数来设置DCB，然后用函数SetCommState()配置串行通信口。
0	 ATT	 1	 例程	 n
1	 ADV	 2	 中	 nd
2	 HED	 -1	 利用	 v
3	 ATT	 4	 BuildCommDCB	 ws
4	 VOB	 2	 函数	 n
5	 ADV	 6	 来	 v
6	 COO	 2	 设置	 v
7	 VOB	 6	 DCB	 ws
8	 WP	 2	 ，	 wp
9	 ADV	 10	 然后	 c
10	 ADV	 15	 用	 p
11	 POB	 10	 函数	 n
12	 COO	 10	 SetCommState	 ws
13	 WP	 10	 (	 wp
14	 WP	 10	 )	 wp
15	 COO	 2	 配置	 v
16	 ATT	 17	 串行	 v
17	 VOB	 15	 通信口	 n
18	 WP	 2	 。	 wp

DCB dcb ;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　//定义设备控制块GetCommState(hComm,&dcb);　　　　　　　　　　　　　　　　　//取出系统缺省设备控制块BuildCommDCB("COM2:9600,N,8,1",&dcb); 　　　　　　　　　　　　　　　//设置DCB主要参数SetCommState(hComm,&dcb);3.3　超时设置API函数　　编写通信应用程序的一个很关键的问题就是如何处理通信中的不可预测的事件。
0	 ATT	 1	 DCB	 ws
1	 HED	 -1	 dcb	 n

譬如接收数据过程中突然被中断，或者发送数据突然停止等等。
0	 ADV	 1	 譬如	 v
1	 HED	 -1	 接收	 v
2	 ATT	 3	 数据	 n
3	 ATT	 4	 过程	 n
4	 ADV	 7	 中	 nd
5	 ADV	 7	 突然	 a
6	 ADV	 7	 被	 p
7	 VOB	 1	 中断	 v
8	 WP	 1	 ，	 wp
9	 ADV	 10	 或者	 c
10	 COO	 1	 发送	 v
11	 VOB	 10	 数据	 n
12	 ADV	 13	 突然	 a
13	 VOB	 10	 停止	 v
14	 RAD	 1	 等等	 u
15	 WP	 1	 。	 wp

如果不认真对待，这些情况可能会引起I/O线程挂起或者线程被无限阻塞。
0	 ADV	 3	 如果	 c
1	 ADV	 3	 不	 d
2	 ADV	 3	 认真	 a
3	 HED	 -1	 对待	 v
4	 WP	 3	 ，	 wp
5	 ATT	 6	 这些	 r
6	 SBV	 9	 情况	 n
7	 ADV	 8	 可能	 v
8	 ADV	 9	 会	 v
9	 COO	 3	 引起	 v
10	 VOB	 9	 I	 ws
11	 WP	 14	 /	 wp
12	 ATT	 13	 O	 ws
13	 SBV	 14	 线程	 n
14	 COO	 9	 挂	 v
15	 CMP	 14	 起	 v
16	 LAD	 19	 或者	 c
17	 FOB	 19	 线程	 n
18	 ADV	 19	 被	 p
19	 COO	 14	 无限	 v
20	 VOB	 19	 阻塞	 v
21	 WP	 3	 。	 wp

Windows95对于这类问题提供了安全措施，它让你通过超时设置来决定通信是否异常并作相应处理。
0	 SBV	 5	 Windows95	 ws
1	 ADV	 5	 对于	 p
2	 ATT	 3	 这	 r
3	 ATT	 4	 类	 q
4	 POB	 1	 问题	 n
5	 HED	 -1	 提供	 v
6	 RAD	 5	 了	 u
7	 ATT	 8	 安全	 a
8	 VOB	 5	 措施	 n
9	 WP	 5	 ，	 wp
10	 SBV	 11	 它	 r
11	 COO	 5	 让	 v
12	 DBL	 11	 你	 r
13	 ADV	 15	 通过	 p
14	 POB	 13	 超时	 v
15	 VOB	 11	 设置	 v
16	 CMP	 15	 来	 v
17	 COO	 15	 决定	 v
18	 VOB	 17	 通信	 v
19	 ADV	 20	 是否	 v
20	 VOB	 18	 异常	 a
21	 ADV	 22	 并	 c
22	 COO	 18	 作	 v
23	 ADV	 24	 相应	 v
24	 VOB	 22	 处理	 v
25	 WP	 11	 。	 wp

因此超时设置在串行通信中显得尤为重要。
0	 ADV	 7	 因此	 c
1	 ADV	 2	 超时	 v
2	 SBV	 7	 设置	 v
3	 ADV	 7	 在	 p
4	 ATT	 6	 串行	 v
5	 COO	 4	 通信	 v
6	 POB	 3	 中	 nd
7	 HED	 -1	 显得	 v
8	 ADV	 9	 尤为	 d
9	 CMP	 7	 重要	 a
10	 WP	 7	 。	 wp

　　超时设置过程分为两步，首先设置COMMTIMEOUTS结构中的五个变量，然后调用SetCommTimeouts()函数设置超时值。
0	 SBV	 1	 	 n
1	 ATT	 3	 超时	 v
2	 COO	 1	 设置	 v
3	 SBV	 4	 过程	 n
4	 HED	 -1	 分为	 v
5	 ATT	 6	 两	 m
6	 VOB	 4	 步	 q
7	 WP	 4	 ，	 wp
8	 ADV	 9	 首先	 d
9	 COO	 4	 设置	 v
10	 ATT	 11	 COMMTIMEOUTS	 ws
11	 ATT	 12	 结构	 n
12	 ATT	 16	 中	 nd
13	 RAD	 12	 的	 u
14	 ATT	 15	 五	 m
15	 ATT	 16	 个	 q
16	 VOB	 9	 变量	 n
17	 WP	 4	 ，	 wp
18	 ADV	 19	 然后	 c
19	 COO	 4	 调用	 v
20	 VOB	 19	 SetCommTimeouts	 ws
21	 WP	 4	 (	 wp
22	 WP	 4	 )	 wp
23	 SBV	 24	 函数	 n
24	 COO	 4	 设置	 v
25	 COO	 24	 超时值	 v
26	 WP	 4	 。	 wp

COMMTIMEOUTS结构的定义如下：　typedef struct —　COMMTIMEOUTS {DWORD ReadIntervalTimeout; 　　　　　　　　　　　　　　　　　　　　　//读端口间隔超时DWORD ReadTotalTimeoutMultiplier;　　　　　　　　　　　　　　　　//读端口总超时乘数DWORD ReadTotalTimeoutConstant; 　　　　　　　　　　　　　　　//读端口总超时常数(ms)DWORD WriteTotalTimeoutMultiplier; 　　　　　　　　　　　　　　　//写端口总超时乘数DWORD WriteTotalTimeoutConstant;　　　　　　　　　　　　　　　//写端口总超时常数(ms)} COMMTIMEOUTS,*LPCOMMTIMEOUTS;3.4　读串口API函数　　串行口打开后，可以对它进行读写操作。
0	 ATT	 1	 COMMTIMEOUTS	 ws
1	 ATT	 3	 结构	 n
2	 RAD	 1	 的	 u
3	 SBV	 4	 定义	 n
4	 HED	 -1	 如下	 v
5	 WP	 4	 ：	 wp
6	 VOB	 4	 	 v
7	 ATT	 8	 typedef	 n
8	 VOB	 6	 struct	 ws
9	 WP	 11	 —	 wp
10	 SBV	 11	 COMMTIMEOUTS	 ws
11	 COO	 6	 {	 v
12	 VOB	 11	 DWORD	 ws
13	 VOB	 4	 ReadIntervalTimeout	 ws

读串行口的函数原型：　BOOL ReadFile (HANDLE hFile, LPVOID lpBuffer,DWORD nNumberOfBytesToRead,LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped data);　　其中,第一个参数hFile是由CreateFile()返回的句柄。
0	 ATT	 11	 读	 v
1	 ATT	 5	 串	 v
2	 VOB	 1	 行口	 n
3	 RAD	 1	 的	 u
4	 ATT	 5	 函数	 n
5	 VOB	 0	 原型	 n
6	 WP	 0	 ：	 wp
7	 COO	 0	 	 v
8	 ATT	 9	 BOOL	 ws
9	 VOB	 7	 ReadFile	 ws
10	 WP	 0	 (	 wp
11	 SBV	 18	 HANDLE	 ws
12	 SBV	 18	 hFile	 ws
13	 WP	 12	 ,	 wp
14	 SBV	 18	 LPVOID	 ws
15	 ATT	 18	 lpBuffer	 ws
16	 WP	 18	 ,	 wp
17	 SBV	 18	 DWORD	 ws
18	 HED	 -1	 nNumberOfBytesToRead	 v
19	 WP	 21	 ,	 wp
20	 SBV	 21	 LPDWORD	 ws
21	 COO	 18	 lpNumberOfBytesRead	 v
22	 WP	 24	 ,	 wp
23	 SBV	 24	 LPOVERLAPPED	 ws
24	 COO	 18	 lpOverlapped	 v
25	 VOB	 24	 data	 nh
26	 WP	 18	 )	 wp

参数lpBuffer是读取的数据缓冲区指针，要注意给该数据缓冲区分配足够的空间；参数nNumberOfBytesToRead是要读取的字节数；参数lpNumberOfBytesRead是实际读取的字节数；最后一个参数lpOverlapped 是指向一个可重叠I/O(异步)的数据结构指针。
0	 ATT	 1	 参数	 n
1	 SBV	 2	 lpBuffer	 nh
2	 HED	 -1	 是	 v
3	 ATT	 7	 读取	 v
4	 RAD	 3	 的	 u
5	 ATT	 6	 数据	 n
6	 ATT	 7	 缓冲区	 n
7	 VOB	 2	 指针	 n
8	 WP	 2	 ，	 wp
9	 ADV	 10	 要	 v
10	 COO	 2	 注意	 v
11	 ADV	 15	 给	 p
12	 ATT	 13	 该	 r
13	 ATT	 14	 数据	 n
14	 POB	 11	 缓冲区	 n
15	 VOB	 10	 分配	 v
16	 ATT	 18	 足够	 v
17	 RAD	 16	 的	 u
18	 VOB	 15	 空间	 n
19	 WP	 2	 ；	 wp

参数lpBuffer是读取的数据缓冲区指针，要注意给该数据缓冲区分配足够的空间；参数nNumberOfBytesToRead是要读取的字节数；参数lpNumberOfBytesRead是实际读取的字节数；最后一个参数lpOverlapped 是指向一个可重叠I/O(异步)的数据结构指针。
0	 SBV	 1	 参数	 n
1	 SBV	 2	 nNumberOfBytesToRead	 v
2	 HED	 -1	 是	 v
3	 ADV	 4	 要	 v
4	 ATT	 7	 读取	 v
5	 RAD	 4	 的	 u
6	 ATT	 7	 字节	 n
7	 VOB	 2	 数	 n
8	 WP	 2	 ；	 wp

参数lpBuffer是读取的数据缓冲区指针，要注意给该数据缓冲区分配足够的空间；参数nNumberOfBytesToRead是要读取的字节数；参数lpNumberOfBytesRead是实际读取的字节数；最后一个参数lpOverlapped 是指向一个可重叠I/O(异步)的数据结构指针。
0	 SBV	 1	 参数	 n
1	 SBV	 2	 lpNumberOfBytesRead	 v
2	 HED	 -1	 是	 v
3	 ADV	 4	 实际	 a
4	 ATT	 7	 读取	 v
5	 RAD	 4	 的	 u
6	 ATT	 7	 字节	 n
7	 VOB	 2	 数	 n
8	 WP	 2	 ；	 wp

参数lpBuffer是读取的数据缓冲区指针，要注意给该数据缓冲区分配足够的空间；参数nNumberOfBytesToRead是要读取的字节数；参数lpNumberOfBytesRead是实际读取的字节数；最后一个参数lpOverlapped 是指向一个可重叠I/O(异步)的数据结构指针。
0	 ATT	 1	 最后	 nd
1	 ATT	 2	 一个	 m
2	 SBV	 3	 参数	 n
3	 SBV	 4	 lpOverlapped	 v
4	 HED	 -1	 是	 v
5	 VOB	 4	 指向	 v
6	 ATT	 18	 一个	 m
7	 ADV	 8	 可	 v
8	 ATT	 18	 重叠	 v
9	 ATT	 13	 I	 ws
10	 WP	 13	 /	 wp
11	 SBV	 13	 O	 ws
12	 WP	 11	 (	 wp
13	 VOB	 8	 异步	 b
14	 WP	 8	 )	 wp
15	 RAD	 8	 的	 u
16	 ATT	 17	 数据	 n
17	 ATT	 18	 结构	 n
18	 VOB	 5	 指针	 n
19	 WP	 4	 。	 wp

如果lpOverlapped设置为NULL，则ReadFile()工作在同步方式；如果lpOverlapped指向一个重叠结构，则工作在异步方式。
0	 ADV	 2	 如果	 c
1	 SBV	 2	 lpOverlapped	 ws
2	 HED	 -1	 设置	 v
3	 COO	 2	 为	 v
4	 POB	 3	 NULL	 ws
5	 WP	 2	 ，	 wp
6	 ADV	 10	 则	 c
7	 SBV	 10	 ReadFile	 ws
8	 WP	 7	 (	 wp
9	 WP	 7	 )	 wp
10	 COO	 2	 工作	 v
11	 CMP	 10	 在	 p
12	 ATT	 13	 同步	 v
13	 POB	 11	 方式	 n
14	 WP	 2	 ；	 wp

如果lpOverlapped设置为NULL，则ReadFile()工作在同步方式；如果lpOverlapped指向一个重叠结构，则工作在异步方式。
0	 ADV	 1	 如果	 c
1	 HED	 -1	 lpOverlapped	 v
2	 VOB	 1	 指向	 v
3	 ATT	 5	 一个	 m
4	 ATT	 5	 重叠	 v
5	 VOB	 2	 结构	 n
6	 WP	 1	 ，	 wp
7	 ADV	 8	 则	 c
8	 COO	 1	 工作	 v
9	 CMP	 8	 在	 p
10	 ATT	 11	 异步	 b
11	 POB	 9	 方式	 n
12	 WP	 1	 。	 wp

3.6　关闭串口API函数　　串行口是非共享资源，某应用程序打开串行口后，即独占该资源，使其它应用程序无法再访问，直到该应用程序释放串口。
0	 ATT	 1	 3.6	 m
1	 ATT	 5	 	 q
2	 ATT	 5	 关闭	 v
3	 ATT	 4	 串口	 ns
4	 VOB	 2	 API	 ws
5	 SBV	 6	 函数	 n
6	 HED	 -1	 串	 v
7	 ATT	 8	 行口	 n
8	 VOB	 6	 是非	 n
9	 COO	 6	 共享	 v
10	 VOB	 9	 资源	 n
11	 WP	 6	 ，	 wp
12	 SBV	 13	 某	 r
13	 ATT	 18	 应用	 v
14	 VOB	 13	 程序	 n
15	 COO	 13	 打开	 v
16	 COO	 15	 串	 v
17	 VOB	 16	 行口	 n
18	 ADV	 21	 后	 nd
19	 WP	 18	 ，	 wp
20	 ADV	 21	 即	 v
21	 COO	 6	 独占	 v
22	 ATT	 23	 该	 r
23	 VOB	 21	 资源	 n
24	 WP	 6	 ，	 wp
25	 COO	 6	 使	 v
26	 DBL	 25	 其它	 r
27	 VOB	 25	 应用	 v
28	 VOB	 27	 程序	 n
29	 ADV	 31	 无法	 v
30	 ADV	 31	 再	 d
31	 COO	 27	 访问	 v
32	 WP	 27	 ，	 wp
33	 COO	 27	 直到	 v
34	 ATT	 35	 该	 r
35	 POB	 33	 应用	 v
36	 VOB	 35	 程序	 n
37	 COO	 35	 释放	 v
38	 VOB	 37	 串口	 n
39	 WP	 6	 。	 wp

所以打开串口后，一定要关闭串口。
0	 ADV	 7	 所以	 c
1	 ATT	 3	 打开	 v
2	 VOB	 1	 串口	 n
3	 ADV	 7	 后	 nd
4	 WP	 3	 ，	 wp
5	 ADV	 6	 一定	 d
6	 ADV	 7	 要	 v
7	 HED	 -1	 关闭	 v
8	 VOB	 7	 串口	 v
9	 WP	 7	 。	 wp

关闭串口函数较简单。
0	 ADV	 4	 关闭	 v
1	 ATT	 2	 串口	 ns
2	 SBV	 4	 函数	 n
3	 ADV	 4	 较	 d
4	 HED	 -1	 简单	 a
5	 WP	 4	 。	 wp

返回值非0，则调用成功。
0	 SBV	 1	 返回	 v
1	 HED	 -1	 值非0	 v
2	 WP	 1	 ，	 wp
3	 ADV	 4	 则	 c
4	 COO	 1	 调用	 v
5	 CMP	 4	 成功	 a
6	 WP	 1	 。	 wp

4　Windows95的串行通信工作方式　　串行通信会话以调用CreateFile()函数打开串行口开始，接着设置串行口波特率、数据位、校验位、停止位等参数以及超时参数，最后选择一种工作方式读、写串行口。
0	 ATT	 1	 4	 m
1	 ATT	 11	 	 q
2	 ATT	 7	 Windows95	 ws
3	 RAD	 2	 的	 u
4	 ATT	 6	 串行	 v
5	 COO	 4	 通信	 v
6	 ATT	 7	 工作	 v
7	 ATT	 10	 方式	 n
8	 ATT	 10	 串行	 v
9	 COO	 8	 通信	 v
10	 ATT	 11	 会	 v
11	 SBV	 18	 话	 n
12	 ADV	 18	 以	 p
13	 POB	 12	 调用	 v
14	 ATT	 17	 CreateFile	 ws
15	 WP	 14	 (	 wp
16	 WP	 14	 )	 wp
17	 VOB	 13	 函数	 n
18	 HED	 -1	 打开	 v
19	 COO	 18	 串	 v
20	 VOB	 19	 行口	 n
21	 COO	 18	 开始	 v
22	 WP	 18	 ，	 wp
23	 ADV	 24	 接着	 c
24	 COO	 18	 设置	 v
25	 ATT	 34	 串	 v
26	 VOB	 25	 行口波特率	 n
27	 WP	 28	 、	 wp
28	 COO	 26	 数据位	 n
29	 WP	 30	 、	 wp
30	 COO	 26	 校验位	 n
31	 WP	 32	 、	 wp
32	 COO	 26	 停止位	 v
33	 RAD	 26	 等	 u
34	 VOB	 24	 参数	 n
35	 LAD	 36	 以及	 c
36	 COO	 34	 超时	 v
37	 VOB	 36	 参数	 n
38	 WP	 18	 ，	 wp
39	 ADV	 40	 最后	 nd
40	 COO	 18	 选择	 v
41	 ATT	 42	 一	 m
42	 ATT	 44	 种	 q
43	 ATT	 44	 工作	 v
44	 VOB	 40	 方式	 n
45	 COO	 40	 读	 v
46	 WP	 47	 、	 wp
47	 COO	 45	 写	 v
48	 ATT	 49	 串	 q
49	 VOB	 47	 行口	 n
50	 WP	 18	 。	 wp

在Windows95中，串行通信有两种工作方式可供选择：查询方式和事件驱动方式。
0	 ADV	 6	 在	 p
1	 ATT	 2	 Windows95	 ws
2	 POB	 0	 中	 nd
3	 WP	 0	 ，	 wp
4	 SBV	 6	 串行	 v
5	 COO	 4	 通信	 v
6	 HED	 -1	 有	 v
7	 ATT	 8	 两	 m
8	 ATT	 20	 种	 q
9	 ATT	 10	 工作	 v
10	 SBV	 12	 方式	 n
11	 ADV	 12	 可	 v
12	 ATT	 16	 供	 v
13	 VOB	 12	 选择	 v
14	 WP	 13	 ：	 wp
15	 COO	 13	 查询	 v
16	 SBV	 19	 方式	 n
17	 LAD	 18	 和	 c
18	 COO	 16	 事件	 n
19	 ATT	 20	 驱动	 v
20	 VOB	 6	 方式	 n
21	 WP	 6	 。	 wp

这两种工作方式各有优缺点，用户可以根据应用程序的实际需要选择其中的一种工作方式，下面对这两种工作方式分别介绍。
0	 ATT	 2	 这	 r
1	 ATT	 2	 两	 m
2	 ATT	 4	 种	 q
3	 ATT	 4	 工作	 v
4	 SBV	 6	 方式	 n
5	 ADV	 6	 各	 r
6	 HED	 -1	 有	 v
7	 VOB	 6	 优缺点	 n
8	 WP	 6	 ，	 wp
9	 SBV	 16	 用户	 n
10	 ADV	 16	 可以	 v
11	 ADV	 16	 根据	 p
12	 ATT	 15	 应用	 v
13	 VOB	 12	 程序	 n
14	 RAD	 12	 的	 u
15	 POB	 11	 实际	 n
16	 COO	 6	 需要	 v
17	 VOB	 16	 选择	 v
18	 ATT	 23	 其中	 r
19	 RAD	 18	 的	 u
20	 ATT	 21	 一	 m
21	 ATT	 23	 种	 q
22	 ATT	 23	 工作	 v
23	 VOB	 17	 方式	 n
24	 WP	 6	 ，	 wp
25	 SBV	 33	 下面	 nd
26	 ADV	 33	 对	 p
27	 ATT	 29	 这	 r
28	 ATT	 29	 两	 m
29	 ATT	 31	 种	 q
30	 ATT	 31	 工作	 v
31	 POB	 26	 方式	 n
32	 ADV	 33	 分别	 d
33	 COO	 6	 介绍	 v
34	 WP	 6	 。	 wp

4.1　查询方式　　对于从串口读取数据来说，查询是最为直接、易于理解的技术。
0	 ATT	 1	 4.1	 m
1	 ATT	 4	 	 q
2	 ATT	 4	 查询	 v
3	 VOB	 2	 方式	 n
4	 SBV	 14	 	 n
5	 ADV	 14	 对于	 p
6	 ADV	 8	 从	 p
7	 POB	 6	 串口	 ns
8	 POB	 5	 读	 v
9	 COO	 8	 取	 v
10	 VOB	 9	 数据	 n
11	 RAD	 5	 来说	 u
12	 WP	 5	 ，	 wp
13	 SBV	 14	 查询	 v
14	 HED	 -1	 是	 v
15	 ADV	 16	 最为	 d
16	 ATT	 21	 直接	 a
17	 WP	 19	 、	 wp
18	 ADV	 19	 易于	 v
19	 COO	 16	 理解	 v
20	 RAD	 16	 的	 u
21	 VOB	 14	 技术	 n
22	 WP	 14	 。	 wp

但是查询会占用大量的CPU时间，效率较低。
0	 ADV	 2	 但是	 c
1	 ADV	 2	 查询会	 v
2	 HED	 -1	 占用	 v
3	 ATT	 6	 大量	 m
4	 RAD	 3	 的	 u
5	 ATT	 6	 CPU	 ws
6	 VOB	 2	 时间	 n
7	 WP	 2	 ，	 wp
8	 SBV	 10	 效率	 n
9	 ADV	 10	 较	 d
10	 COO	 2	 低	 a
11	 WP	 2	 。	 wp

利用查询方式读取串口数据时通常要建立一个线程，建立线程使用CreateThread()函数。
0	 ATT	 7	 利用	 v
1	 ATT	 2	 查询	 v
2	 VOB	 0	 方式	 n
3	 COO	 0	 读	 v
4	 COO	 0	 取	 v
5	 ATT	 6	 串口	 ns
6	 VOB	 4	 数据	 n
7	 ADV	 10	 时	 n
8	 ADV	 9	 通常	 d
9	 ADV	 10	 要	 v
10	 HED	 -1	 建立	 v
11	 ATT	 12	 一个	 m
12	 VOB	 10	 线程	 n
13	 WP	 10	 ，	 wp
14	 COO	 10	 建立	 v
15	 SBV	 16	 线程	 n
16	 ATT	 20	 使用	 v
17	 VOB	 16	 CreateThread	 ws
18	 WP	 16	 (	 wp
19	 WP	 16	 )	 wp
20	 VOB	 14	 函数	 n
21	 WP	 10	 。	 wp

循环查询在线程里进行。
0	 FOB	 5	 循环	 v
1	 COO	 0	 查询	 v
2	 ADV	 5	 在	 p
3	 ATT	 4	 线程	 n
4	 POB	 2	 里	 nd
5	 HED	 -1	 进行	 v
6	 WP	 5	 。	 wp

举例：（假设端口已经打开)　DWORD ReadThread(LPDWORD lpdwParam){ BYTE Buff［100］; 　　　　　　　　　　　　　　　　　　　　　　　　　//读数据缓冲区DWORD nBytesRead; 　　　　　　　　　　　　　　　　　　　　　　　　//实际读取的字节数COMMTIMEOUTS Timeouts;　　　　　　　　　　　　　　　　　　　　　　　　　　//超时设置Memset(&Timeouts,0,sizeof(COMMTIMEOUTS));Timeouts.ReadIntervalTimeout = MAXDWORD;SetCommTimeouts(hComm,&Timeouts);While(bReading){if(!ReadFile(hComm,Buff,100,&nBytesRead,NULL)){………　　　　　　　　　　　　　　　　　　　　　　　　　　　　　//读取数据出错处理}else{………　　　　　　　　　　　　　　　　　　　　　　　　　　//正确读取数据的处理}}PurgeComm(hComm,PURGE—RXCLEAR);return 0;}　　例程中，线程的退出由bReading标志控制，当bReading为TRUE时，循环串口；当breading为FALSE时，线程退出。
0	 HED	 -1	 举例	 v
1	 WP	 0	 ：	 wp
2	 WP	 6	 （	 wp
3	 ATT	 4	 假设	 v
4	 FOB	 6	 端口	 n
5	 ADV	 6	 已经	 d
6	 VOB	 0	 打开	 v
7	 WP	 19	 )	 wp
8	 ATT	 9	 	 n
9	 ATT	 13	 DWORD	 ws
10	 ATT	 13	 ReadThread	 ws
11	 WP	 13	 (	 wp
12	 ATT	 13	 LPDWORD	 ws
13	 ATT	 19	 lpdwParam	 n
14	 WP	 15	 )	 wp
15	 COO	 13	 {	 v
16	 VOB	 15	 BYTE	 ws
17	 COO	 13	 Buff	 ws
18	 WP	 19	 ［	 wp
19	 VOB	 6	 100	 m
20	 WP	 0	 ］	 wp

4.2　事件驱动方式　　事件驱动I/O方式是指线程通过监视通信资源中的一组事件来进行I/O操作，这种方式类似于MSDOS下的中断工作方式，效率高。
0	 ATT	 1	 4.2	 m
1	 ATT	 2	 	 q
2	 SBV	 3	 事件	 n
3	 ATT	 4	 驱动	 v
4	 SBV	 5	 方式	 n
5	 ATT	 6	 	 v
6	 SBV	 7	 事件	 n
7	 SBV	 13	 驱动	 v
8	 VOB	 7	 I	 ws
9	 WP	 12	 /	 wp
10	 ATT	 11	 O	 ws
11	 SBV	 12	 方式	 n
12	 ADV	 13	 是	 v
13	 HED	 -1	 指	 v
14	 SBV	 25	 线程	 n
15	 ADV	 25	 通过	 p
16	 POB	 15	 监视	 v
17	 ATT	 18	 通信	 v
18	 ATT	 19	 资源	 n
19	 ATT	 23	 中	 nd
20	 RAD	 19	 的	 u
21	 ATT	 22	 一	 m
22	 ATT	 23	 组	 q
23	 VOB	 16	 事件	 n
24	 ADV	 25	 来	 v
25	 VOB	 13	 进行	 v
26	 ATT	 29	 I	 ws
27	 WP	 29	 /	 wp
28	 SBV	 29	 O	 ws
29	 VOB	 25	 操作	 v
30	 WP	 29	 ，	 wp
31	 ATT	 32	 这种	 r
32	 SBV	 38	 方式	 n
33	 ADV	 38	 类似	 v
34	 CMP	 33	 于	 p
35	 ATT	 36	 MSDOS	 ws
36	 POB	 34	 下	 nd
37	 RAD	 33	 的	 u
38	 COO	 29	 中断	 v
39	 ATT	 40	 工作	 v
40	 VOB	 38	 方式	 n
41	 WP	 38	 ，	 wp
42	 SBV	 43	 效率	 n
43	 COO	 38	 高	 a
44	 WP	 13	 。	 wp

可被监视的事件列表如下：事件掩码含义EV—BREAK检测到输入终止EV—CTSCTS(清除发送)信号改变状态EV—DSRDSR(数据设置就绪)信号改变状态EV—ERR发生了线路状态错误EV—RING检测到振铃EV—RLSDRLSD信号改变状态EV—RXCHAR收到任何字符并放进输入缓冲区EV—RXFLAG收到事件字符，并放进输入缓冲区EV—TXEMPTY输出缓冲区中最后一个字符发送出去　　实际编程中，对串行口的读、写操作需要建立两个工作者线程。
0	 ADV	 5	 可	 c
1	 ADV	 5	 被	 p
2	 ATT	 4	 监视	 v
3	 RAD	 2	 的	 u
4	 POB	 1	 事件	 n
5	 SBV	 6	 列表	 v
6	 HED	 -1	 如下	 v
7	 WP	 6	 ：	 wp
8	 SBV	 9	 事件	 n
9	 VOB	 6	 掩码	 v
10	 VOB	 9	 含义	 n
11	 SBV	 12	 EV—BREAK	 ws
12	 COO	 9	 检测	 v
13	 CMP	 12	 到	 v
14	 COO	 9	 输入	 v
15	 VOB	 14	 终止	 v
16	 VOB	 15	 EV—CTSCTS	 ws
17	 WP	 14	 (	 wp
18	 COO	 14	 清除	 v
19	 VOB	 18	 发送	 v
20	 WP	 14	 )	 wp
21	 SBV	 22	 信号	 n
22	 COO	 14	 改变	 v
23	 VOB	 22	 状态	 n
24	 VOB	 23	 EV—DSRDSR	 ws
25	 WP	 14	 (	 wp
26	 SBV	 27	 数据	 n
27	 COO	 14	 设置	 v
28	 COO	 27	 就绪	 v
29	 WP	 14	 )	 wp
30	 SBV	 31	 信号	 n
31	 COO	 14	 改变	 v
32	 ATT	 33	 状态	 n
33	 SBV	 34	 EV—ERR	 ws
34	 ATT	 38	 发生	 v
35	 RAD	 34	 了	 u
36	 ATT	 37	 线路	 n
37	 VOB	 34	 状态	 n
38	 VOB	 31	 错误	 n
39	 SBV	 40	 EV—RING	 ws
40	 COO	 31	 检测	 v
41	 CMP	 40	 到	 v
42	 ATT	 44	 振铃	 nz
43	 ATT	 44	 EV—RLSDRLSD	 ws
44	 POB	 41	 信号	 n
45	 VOB	 40	 改变	 v
46	 VOB	 45	 状态	 n
47	 SBV	 48	 EV—RXCHAR	 ws
48	 COO	 45	 收到	 v
49	 ATT	 50	 任何	 r
50	 VOB	 48	 字符	 n
51	 ADV	 52	 并	 c
52	 COO	 48	 放	 v
53	 CMP	 52	 进	 v
54	 COO	 53	 输入	 v
55	 VOB	 54	 缓冲区	 n
56	 SBV	 57	 EV—RXFLAG	 ws
57	 COO	 52	 收到	 v
58	 ATT	 59	 事件	 n
59	 VOB	 57	 字符	 n
60	 WP	 52	 ，	 wp
61	 ADV	 62	 并	 c
62	 COO	 52	 放	 v
63	 CMP	 62	 进	 v
64	 COO	 63	 输入	 v
65	 VOB	 64	 缓冲区	 n
66	 SBV	 67	 EV—TXEMPTY	 ws
67	 COO	 63	 输出	 v
68	 ATT	 69	 缓冲区	 n
69	 ATT	 72	 中	 nd
70	 ATT	 71	 最后	 nd
71	 ATT	 72	 一个	 m
72	 DBL	 67	 字符	 n
73	 COO	 62	 发送	 v
74	 CMP	 73	 出去	 v
75	 COO	 62	 	 v
76	 ADV	 77	 实际	 a
77	 ATT	 78	 编程	 v
78	 ADV	 83	 中	 nd
79	 WP	 78	 ，	 wp
80	 ADV	 83	 对	 p
81	 POB	 80	 串行口	 ns
82	 RAD	 80	 的	 u
83	 SBV	 87	 读	 v
84	 WP	 85	 、	 wp
85	 SBV	 87	 写	 v
86	 CMP	 85	 操作	 v
87	 ADV	 88	 需要	 v
88	 COO	 62	 建立	 v
89	 ATT	 90	 两	 m
90	 ATT	 92	 个	 q
91	 ATT	 92	 工作者	 n
92	 VOB	 88	 线程	 n
93	 WP	 45	 。	 wp

在读或写线程中可以通过SetCommMask()函数设置事件屏蔽来监视指定通信资源上的事件。
0	 ADV	 12	 在	 p
1	 ATT	 5	 读	 v
2	 LAD	 3	 或	 c
3	 COO	 1	 写	 v
4	 VOB	 1	 线程	 n
5	 POB	 0	 中	 nd
6	 ADV	 12	 可以	 v
7	 ADV	 12	 通过	 p
8	 POB	 7	 SetCommMask	 ws
9	 WP	 7	 (	 wp
10	 WP	 7	 )	 wp
11	 SBV	 12	 函数	 n
12	 ATT	 13	 设置	 v
13	 SBV	 14	 事件	 n
14	 HED	 -1	 屏蔽	 v
15	 CMP	 14	 来	 v
16	 COO	 14	 监视	 v
17	 COO	 14	 指定	 v
18	 ATT	 19	 通信	 v
19	 ATT	 20	 资源	 n
20	 ATT	 22	 上	 nd
21	 RAD	 20	 的	 u
22	 VOB	 17	 事件	 n
23	 WP	 14	 。	 wp

指定一组事件后，线程可以使用WaitCommEvent()函数等待其中一个事件发生，在等待过程中它将花费极少的CPU时间。
0	 ATT	 4	 指定	 v
1	 ATT	 2	 一	 m
2	 ATT	 3	 组	 q
3	 DBL	 0	 事件	 n
4	 ADV	 8	 后	 nd
5	 WP	 4	 ，	 wp
6	 SBV	 8	 线程	 n
7	 ADV	 8	 可以	 v
8	 HED	 -1	 使用	 v
9	 VOB	 8	 WaitCommEvent	 ws
10	 WP	 8	 (	 wp
11	 WP	 8	 )	 wp
12	 SBV	 13	 函数	 n
13	 COO	 8	 等待	 v
14	 ATT	 16	 其中	 r
15	 ATT	 16	 一个	 m
16	 SBV	 17	 事件	 n
17	 VOB	 13	 发生	 v
18	 WP	 13	 ，	 wp
19	 ADV	 25	 在	 p
20	 ATT	 21	 等待	 v
21	 ATT	 22	 过程	 n
22	 POB	 19	 中	 nd
23	 SBV	 25	 它	 r
24	 ADV	 25	 将	 d
25	 COO	 13	 花费	 v
26	 ADV	 27	 极	 d
27	 ATT	 30	 少	 a
28	 RAD	 27	 的	 u
29	 ATT	 30	 CPU	 ws
30	 VOB	 25	 时间	 n
31	 WP	 13	 。	 wp

注意：WaitCommEvent()函数和读写操作函数一样可以同步使用，也可以异步使用，这主要取决于在第三个参数中是否指定OVERLAPPED结构。
0	 SBV	 23	 注意	 v
1	 WP	 0	 ：	 wp
2	 SBV	 13	 WaitCommEvent	 ws
3	 WP	 13	 (	 wp
4	 WP	 13	 )	 wp
5	 SBV	 13	 函数	 n
6	 LAD	 7	 和	 c
7	 COO	 5	 读	 v
8	 COO	 7	 写	 v
9	 CMP	 8	 操作	 v
10	 VOB	 8	 函数	 n
11	 ADV	 13	 一样	 a
12	 ADV	 13	 可以	 v
13	 VOB	 0	 同步	 v
14	 COO	 13	 使用	 v
15	 WP	 13	 ，	 wp
16	 ADV	 19	 也	 d
17	 ADV	 19	 可以	 v
18	 ADV	 19	 异步	 d
19	 COO	 13	 使用	 v
20	 WP	 0	 ，	 wp
21	 SBV	 23	 这	 r
22	 ADV	 23	 主要	 d
23	 HED	 -1	 取决于	 v
24	 ADV	 30	 在	 p
25	 ATT	 26	 第三	 m
26	 ATT	 27	 个	 q
27	 ATT	 28	 参数	 n
28	 POB	 24	 中	 nd
29	 ADV	 30	 是否	 v
30	 VOB	 23	 指定	 v
31	 ATT	 32	 OVERLAPPED	 ws
32	 VOB	 30	 结构	 n
33	 WP	 23	 。	 wp

如果指定为NULL，该函数就是同步的，必须等到SetCommMask()中指定的事件有一个发生时它才返回；如果指定了一个OVERLAPPED结构，该函数即工作在异步方式。
0	 ADV	 1	 如果	 c
1	 ATT	 17	 指定	 v
2	 CMP	 1	 为	 v
3	 POB	 2	 NULL	 ws
4	 WP	 1	 ，	 wp
5	 ATT	 6	 该	 v
6	 SBV	 8	 函数	 n
7	 ADV	 8	 就	 d
8	 COO	 1	 是	 v
9	 VOB	 8	 同步	 v
10	 RAD	 9	 的	 u
11	 WP	 1	 ，	 wp
12	 ADV	 13	 必须	 d
13	 COO	 1	 等到	 v
14	 VOB	 13	 SetCommMask	 ws
15	 WP	 13	 (	 wp
16	 WP	 1	 )	 wp
17	 ADV	 18	 中	 nd
18	 ATT	 20	 指定	 v
19	 RAD	 18	 的	 u
20	 SBV	 21	 事件	 n
21	 HED	 -1	 有	 v
22	 ATT	 24	 一个	 m
23	 ATT	 24	 发生	 v
24	 ADV	 27	 时	 n
25	 SBV	 27	 它	 r
26	 ADV	 27	 才	 d
27	 VOB	 21	 返回	 v
28	 WP	 21	 ；	 wp

如果指定为NULL，该函数就是同步的，必须等到SetCommMask()中指定的事件有一个发生时它才返回；如果指定了一个OVERLAPPED结构，该函数即工作在异步方式。
0	 ADV	 1	 如果	 c
1	 HED	 -1	 指定	 v
2	 RAD	 1	 了	 u
3	 ATT	 5	 一个	 m
4	 ATT	 5	 OVERLAPPED	 ws
5	 VOB	 1	 结构	 n
6	 WP	 1	 ，	 wp
7	 ATT	 8	 该	 r
8	 SBV	 9	 函数	 n
9	 COO	 1	 即	 v
10	 VOB	 9	 工作	 v
11	 CMP	 10	 在	 p
12	 ATT	 13	 异步	 b
13	 POB	 11	 方式	 n
14	 WP	 1	 。	 wp

通常将该函数工作在同步方式。
0	 ADV	 4	 通常	 d
1	 ADV	 4	 将	 p
2	 ATT	 3	 该	 r
3	 POB	 1	 函数	 n
4	 HED	 -1	 工作	 v
5	 CMP	 4	 在	 p
6	 ATT	 7	 同步	 v
7	 POB	 5	 方式	 n
8	 WP	 4	 。	 wp

　　下面的例程演示了利用事件驱动I/O方式从串行口读取数据。
0	 ATT	 1	 	 n
1	 ATT	 3	 下面	 nd
2	 RAD	 1	 的	 u
3	 SBV	 4	 例程	 n
4	 ATT	 7	 演示	 v
5	 RAD	 4	 了	 u
6	 ATT	 7	 利用	 v
7	 SBV	 8	 事件	 n
8	 HED	 -1	 驱动	 v
9	 VOB	 8	 I	 ws
10	 WP	 11	 /	 wp
11	 COO	 8	 O	 v
12	 VOB	 11	 方式	 n
13	 ADV	 15	 从	 p
14	 POB	 13	 串行口	 ns
15	 COO	 11	 读	 v
16	 COO	 15	 取	 v
17	 VOB	 16	 数据	 n
18	 WP	 8	 。	 wp

DWORD ReadThread(LPDWORD lpdwParam){ BYTE Buff［100］; 　　　　　　　　　　　　　　　　　　　　　　　　　//读数据缓冲区DWORD nBytesRead, dwEvent, dwError;COMMTIMEOUTS Timeouts;　　　　　　　　　　　　　　　　　　　　　　　　　　//超时设置Memset(&Timeouts,0,sizeof(COMMTIMEOUTS));Timeouts.ReadTotalTimeoutMultiplier=5;Timeouts.ReadTotalTimeoutConstant=100;SetCommTimeouts(hComm,&Timeouts);SetCommMask(hComm,EV—RXCHAR);　　　　//设置EV—RXCHAR掩码，当任何字符到达时产生事件While(bReading){if(WaitCommEvent(hComm,&dwEvent,NULL)){　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　//接收缓冲区有字符到达if(dwEvent & EV—RXCHAR){ 　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　//确认是EV—RXCHAR事件if(!ReadFile(hComm,Buff,1,&nBytesRead,NULL)){……　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　//处理读错误}else{……　　　　　　　　　　　　　　　　　　　　　　　　　　　　//正确接收字符处理}}else{……　　　　　　　　　　　　　　　　　　　　　　　　　//非EV—RXCHAR事件的处理} }}PurgeComm(hComm,PURGE—RXCLEAR);return 0;}　　在上面的例程中，设置EV—RXCHAR事件掩码，则告诉Windows无论何时接收到一个字节，就产生一个事件。
0	 ATT	 4	 DWORD	 ws
1	 ATT	 4	 ReadThread	 ws
2	 WP	 4	 (	 wp
3	 ATT	 4	 LPDWORD	 ws
4	 HED	 -1	 lpdwParam	 n
5	 WP	 10	 )	 wp
6	 ATT	 10	 {	 v
7	 VOB	 6	 BYTE	 ws
8	 ATT	 10	 Buff	 ws
9	 WP	 10	 ［	 wp
10	 COO	 4	 100	 m
11	 WP	 10	 ］	 wp

在WaitCommEvent()返回后，比较该函数返回的事件掩码，如果是EV—RXCHAR，则说明接收缓冲区中至少有一个字符处于等待状态；否则，就是错误事件，需要进行错误处理。
0	 ADV	 16	 在	 p
1	 ATT	 12	 WaitCommEvent	 ws
2	 WP	 1	 (	 wp
3	 WP	 10	 )	 wp
4	 ATT	 5	 返回	 v
5	 ADV	 10	 后	 nd
6	 WP	 5	 ，	 wp
7	 ADV	 8	 比较	 d
8	 ADV	 9	 该	 v
9	 SBV	 10	 函数	 n
10	 ATT	 12	 返回	 v
11	 RAD	 10	 的	 u
12	 ATT	 13	 事件	 n
13	 POB	 0	 掩码	 n
14	 WP	 0	 ，	 wp
15	 ADV	 16	 如果	 c
16	 HED	 -1	 是	 v
17	 VOB	 16	 EV—RXCHAR	 ws
18	 WP	 16	 ，	 wp
19	 ADV	 20	 则	 c
20	 ADV	 25	 说明	 v
21	 VOB	 20	 接收	 v
22	 ATT	 23	 缓冲区	 n
23	 ADV	 25	 中	 nd
24	 ADV	 25	 至少	 d
25	 COO	 16	 有	 v
26	 ATT	 27	 一个	 m
27	 DBL	 25	 字符	 n
28	 VOB	 25	 处于	 v
29	 ATT	 30	 等待	 v
30	 VOB	 28	 状态	 n
31	 WP	 16	 ；	 wp

在WaitCommEvent()返回后，比较该函数返回的事件掩码，如果是EV—RXCHAR，则说明接收缓冲区中至少有一个字符处于等待状态；否则，就是错误事件，需要进行错误处理。
0	 ADV	 3	 否则	 c
1	 WP	 0	 ，	 wp
2	 ADV	 3	 就	 d
3	 HED	 -1	 是	 v
4	 ATT	 5	 错误	 a
5	 VOB	 3	 事件	 n
6	 WP	 3	 ，	 wp
7	 ADV	 8	 需要	 v
8	 COO	 3	 进行	 v
9	 ADV	 10	 错误	 a
10	 VOB	 8	 处理	 v
11	 WP	 3	 。	 wp

5　效果　　作者在开发的“公安110智能报警系统”时利用事件驱动方式的串行通信编程技术处理多种系统设备间频繁的数据交换任务，应用非常成功。
0	 ATT	 1	 5	 m
1	 ATT	 3	 	 q
2	 ATT	 3	 效果	 n
3	 SBV	 20	 作者	 n
4	 ADV	 20	 在	 p
5	 ATT	 18	 开发	 v
6	 RAD	 5	 的	 u
7	 WP	 11	 “	 wp
8	 ATT	 10	 公安	 n
9	 ATT	 10	 110	 m
10	 SBV	 11	 智能	 n
11	 ATT	 14	 报警	 v
12	 VOB	 11	 系统	 n
13	 WP	 11	 ”	 wp
14	 ADV	 17	 时	 n
15	 ATT	 16	 利用	 v
16	 SBV	 17	 事件	 n
17	 ATT	 18	 驱动	 v
18	 POB	 4	 方式	 n
19	 RAD	 4	 的	 u
20	 HED	 -1	 串行	 v
21	 COO	 20	 通信	 v
22	 COO	 20	 编程	 v
23	 VOB	 22	 技术	 n
24	 VOB	 22	 处理	 v
25	 ATT	 26	 多种	 m
26	 ATT	 27	 系统	 n
27	 ATT	 28	 设备	 n
28	 ATT	 33	 间	 nd
29	 ATT	 33	 频繁	 a
30	 RAD	 29	 的	 u
31	 SBV	 32	 数据	 n
32	 ATT	 33	 交换	 v
33	 VOB	 24	 任务	 n
34	 WP	 22	 ，	 wp
35	 COO	 22	 应用	 v
36	 ADV	 37	 非常	 d
37	 CMP	 35	 成功	 a
38	 WP	 20	 。	 wp

系统可实时地监控从市话网上不断传来的报警电话。
0	 SBV	 4	 系统	 n
1	 ADV	 4	 可	 v
2	 VOB	 1	 实时	 n
3	 RAD	 1	 地	 u
4	 HED	 -1	 监控	 v
5	 ADV	 9	 从	 p
6	 ATT	 7	 市话网	 n
7	 POB	 5	 上	 nd
8	 ADV	 9	 不断	 d
9	 ATT	 11	 传来	 v
10	 RAD	 9	 的	 u
11	 VOB	 4	 报警	 v
12	 VOB	 11	 电话	 n
13	 WP	 4	 。	 wp

作者简介：郭峰林　硕士研究生。
0	 SBV	 1	 作者	 n
1	 ADV	 4	 简介	 n
2	 WP	 1	 ：	 wp
3	 SBV	 4	 郭峰林	 nh
4	 HED	 -1	 	 v
5	 ATT	 6	 硕士	 n
6	 VOB	 4	 研究生	 n
7	 WP	 4	 。	 wp

朱才连　博士生导师，研究员。
0	 SBV	 1	 朱才连	 nh
1	 HED	 -1	 	 v
2	 ATT	 3	 博士生	 n
3	 VOB	 1	 导师	 n
4	 WP	 1	 ，	 wp
5	 COO	 1	 研究员	 n
6	 WP	 1	 。	 wp

师，研究员。
0	 SBV	 1	 朱才连	 nh
1	 HED	 -1	 　	 v
2	 ATT	 3	 博士生	 n
3	 VOB	 1	 导师	 n
4	 WP	 1	 ，	 wp
5	 COO	 1	 研究员	 n
6	 WP	 1	 。	 wp

